{% extends "base.html" %}

{% block title %}Add Book - BookOracle{% endblock %}

{% block content %}
<div class="hero bg-gradient-to-br from-primary to-secondary text-primary-content py-12 rounded-box mb-8">
  <div class="hero-content text-center">
    <div>
      <h1 class="text-5xl font-bold mb-4">📚 Add New Book</h1>
      <p class="text-xl opacity-90">Scan or search for books to add to your library</p>
    </div>
  </div>
</div>

<div class="card bg-base-100 shadow-xl">
  <div class="card-body">
    <form method="post" class="space-y-6">
      <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
      
      <!-- Scanner Section -->
      <div class="card bg-base-200 border-2 border-primary/20">
        <div class="card-body">
          <h3 class="card-title text-primary mb-4">
            📱 Barcode Scanner
          </h3>
          
          <!-- Scanner Tips -->
          <div class="alert alert-info mb-4">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <div>
              <h4 class="font-bold">Scanner Tips</h4>
              <div class="text-sm">
                <p><strong>Native App:</strong> Best experience with automatic scanning</p>
                <p><strong>Browser:</strong> Works but may be slower on mobile devices</p>
              </div>
            </div>
          </div>
          
          <!-- Scanner Controls -->
          <div class="flex flex-wrap gap-2 mt-4">
            <button id="scannerBtn" type="button" class="btn btn-primary btn-lg" onclick="handleScannerButtonClick(event)">
              📷 Scan Barcode
            </button>
            
            <button id="debugBtn" type="button" class="btn btn-secondary btn-sm" onclick="debugScanner()" style="display: none;">
              🔍 Debug Scanner
            </button>
            
            <button id="cleanupBtn" type="button" class="btn btn-warning btn-sm" onclick="manualCameraCleanup()" style="display: none;">
              🛑 Release Camera
            </button>
            
            <button id="nuclearBtn" type="button" class="btn btn-error btn-sm" onclick="nuclearCameraRelease()" style="display: none;">
              ☢️ Nuclear Release
            </button>
          </div>
          
          <!-- Scanner Viewport -->
          <div id="scanner" class="hidden w-full max-w-md h-80 mx-auto relative bg-black rounded-box overflow-hidden">
            <video id="scanner-video" class="w-full h-full object-cover rounded-box" autoplay playsinline muted></video>
            <div id="scanner-overlay" class="scanner-overlay absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-48 h-48 rounded-box pointer-events-none"></div>
          </div>
          
          <!-- Scanner Status -->
          <div id="scannerStatus" class="hidden mt-4"></div>
        </div>
      </div>

      <!-- ISBN and Fetch Section -->
      <div class="form-control">
        <label class="label">
          <span class="label-text text-lg font-semibold">📖 ISBN Number</span>
        </label>
        <div class="join w-full">
          <input id="isbn" name="isbn" class="input input-bordered join-item flex-1" 
                 value="{{ request.form.isbn or '' }}" 
                 type="text" pattern="[0-9\-]+" title="Enter a valid ISBN (digits and hyphens only)"
                 placeholder="Enter ISBN or scan barcode above">
          <button id="fetchBtn" name="fetch" value="1" type="button" class="btn btn-secondary join-item">
            🔍 Fetch Book Data
          </button>
        </div>
      </div>

      <!-- Book Details -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">📚 Title</span>
          </label>
          <input id="title" name="title" class="input input-bordered" 
                 value="{{ book_data.title if book_data else request.form.title or '' }}"
                 placeholder="Enter book title">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">✍️ Author</span>
          </label>
          <input id="author" name="author" class="input input-bordered" 
                 value="{{ book_data.author if book_data else request.form.author or '' }}"
                 placeholder="Enter author name">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">🏢 Publisher</span>
          </label>
          <input id="publisher" name="publisher" class="input input-bordered" 
                 value="{{ book_data.publisher if book_data else request.form.publisher or '' }}"
                 placeholder="Enter publisher name">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">📅 Publication Date</span>
          </label>
          <input id="publication_date" name="publication_date" class="input input-bordered" 
                 value="{{ book_data.published_date if book_data else request.form.publication_date or '' }}"
                 placeholder="Enter publication date">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">📄 Pages</span>
          </label>
          <input id="pages" name="pages" class="input input-bordered" 
                 value="{{ book_data.page_count if book_data else request.form.pages or '' }}"
                 placeholder="Enter number of pages">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">🌐 Language</span>
          </label>
          <input id="language" name="language" class="input input-bordered" 
                 value="{{ book_data.language if book_data else request.form.language or '' }}"
                 placeholder="Enter language">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">📦 Format</span>
          </label>
          <input id="format" name="format" class="input input-bordered" 
                 value="{{ book_data.format if book_data else request.form.format or '' }}"
                 placeholder="Enter format (optional)">
        </div>
        
        <div class="form-control">
          <label class="label">
            <span class="label-text text-lg font-semibold">📝 Description</span>
          </label>
          <textarea id="description" name="description" class="textarea textarea-bordered h-24"
                    placeholder="Enter book description">{{ book_data.description if book_data else request.form.description or '' }}</textarea>
        </div>
      </div>

      <!-- Book Cover Preview -->
      <div class="card bg-base-200">
        <div class="card-body text-center">
          <h3 class="card-title text-primary mb-4">📸 Book Cover</h3>
          <img id="coverPreviewImg" 
               src="{{ book_data.cover if book_data and book_data.cover else url_for('static', filename='bookshelf.png') }}" 
               alt="Book Cover" 
               class="max-h-56 rounded-box shadow-lg mx-auto">
        </div>
      </div>

      <!-- Reading Options -->
      <div class="card bg-base-200">
        <div class="card-body">
          <h3 class="card-title text-primary mb-4">⚙️ Reading Options</h3>
          <div class="space-y-4">
            <label class="label cursor-pointer justify-start gap-4">
              <input type="checkbox" name="want_to_read" class="checkbox checkbox-primary" 
                     {% if request.form.want_to_read %}checked{% endif %}>
              <span class="label-text text-lg">📋 Want to Read (Add to reading list)</span>
            </label>
            <label class="label cursor-pointer justify-start gap-4">
              <input type="checkbox" name="library_only" class="checkbox checkbox-primary" 
                     {% if request.form.library_only %}checked{% endif %}>
              <span class="label-text text-lg">📚 Library Only (Reference/Collection)</span>
            </label>
          </div>
        </div>
      </div>

      <!-- Submit Button -->
      <div class="flex justify-center">
        <button type="submit" name="add" class="btn btn-primary btn-lg btn-wide">
          ➕ Add Book to Library
        </button>
      </div>
    </form>

    <!-- Back Link -->
    <div class="text-center mt-8">
      <a href="{{ url_for('main.index') }}" class="btn btn-outline btn-wide">
        ⬅️ Back to Library
      </a>
    </div>
  </div>
</div>

<!-- Early environment detection setup -->
<script>
// Function to check native scanner availability
function checkNativeScannerAvailability() {
  // Set up environment detection
  window.isCapacitor = typeof Capacitor !== 'undefined';
  window.isNative = window.isCapacitor && Capacitor.isNative;
  window.platform = window.isCapacitor ? Capacitor.getPlatform() : 'web';

  console.log('[Scanner] Environment detection:', {
    isCapacitor: window.isCapacitor,
    isNative: window.isNative,
    platform: window.platform,
    Capacitor: typeof Capacitor,
    CapacitorIsNative: window.isCapacitor ? Capacitor.isNative : 'N/A',
    CapacitorPlugins: window.isCapacitor ? Object.keys(Capacitor.Plugins || {}) : 'N/A'
  });

  // Check if native scanner is available
  const nativeScannerAvailable = window.isCapacitor && 
                                window.platform !== 'web' && 
                                typeof Capacitor !== 'undefined' && 
                                Capacitor.Plugins && 
                                Capacitor.Plugins.BarcodeScanner;

  console.log('[Scanner] Native scanner availability:', {
    nativeScannerAvailable,
    shouldLoadZXing: !nativeScannerAvailable
  });

  // Only load ZXing if native scanner is not available
  if (!nativeScannerAvailable) {
    console.log('[Scanner] Native scanner not available, loading ZXing library...');
    
    // Dynamically load ZXing library
    const zxingScript = document.createElement('script');
    zxingScript.src = "{{ url_for('static', filename='node_modules/@zxing/browser/umd/index.min.js') }}";
    zxingScript.onload = function() {
      console.log('[Scanner] ZXing library loaded successfully');
      
      // Check if ZXing library loaded correctly
      console.log('[Scanner] ZXing library check:', {
        ZXingBrowser: typeof ZXingBrowser,
        BrowserMultiFormatReader: typeof ZXingBrowser !== 'undefined' ? typeof ZXingBrowser.BrowserMultiFormatReader : 'N/A'
      });
      
      if (typeof ZXingBrowser === 'undefined') {
        console.error('[Scanner] ZXing library failed to load!');
      }
      
      // Load ZXing scanner module after library is loaded
      const zxingModuleScript = document.createElement('script');
      zxingModuleScript.src = "{{ url_for('static', filename='scanner-zxing.js') }}";
      zxingModuleScript.onload = function() {
        console.log('[Scanner] ZXing scanner module loaded');
      };
      document.head.appendChild(zxingModuleScript);
    };
    zxingScript.onerror = function() {
      console.error('[Scanner] Failed to load ZXing library');
    };
    document.head.appendChild(zxingScript);
  } else {
    console.log('[Scanner] Native scanner available, skipping ZXing library load');
  }
}

// Wait for Capacitor to be available, with multiple attempts
function waitForCapacitor() {
  if (typeof Capacitor !== 'undefined') {
    console.log('[Scanner] Capacitor detected immediately');
    checkNativeScannerAvailability();
  } else {
    console.log('[Scanner] Capacitor not detected, waiting...');
    // Try again after a short delay
    setTimeout(() => {
      if (typeof Capacitor !== 'undefined') {
        console.log('[Scanner] Capacitor detected after delay');
        checkNativeScannerAvailability();
      } else {
        console.log('[Scanner] Capacitor still not detected, assuming web environment');
        checkNativeScannerAvailability();
      }
    }, 100);
  }
}

// Start the detection process
waitForCapacitor();
</script>

<!-- Load modular scanner scripts (always load core modules) -->
<script src="{{ url_for('static', filename='scanner-utils.js', v='1.1') }}"></script>
<script src="{{ url_for('static', filename='scanner-native.js', v='1.1') }}"></script>
<script src="{{ url_for('static', filename='scanner-core.js', v='1.1') }}"></script>
<!-- ZXing scanner module is loaded conditionally above -->
<script src="{{ url_for('static', filename='scanner-ui.js', v='1.1') }}"></script>
<script src="{{ url_for('static', filename='scanner-data.js', v='1.1') }}"></script>
<script src="{{ url_for('static', filename='scanner.js', v='1.1') }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('[AddBook] Page loaded, initializing scanner...');
  
  // Initialize scanner modules
  if (window.ScannerCore) {
    console.log('[AddBook] ScannerCore available');
  }
  
  if (window.ScannerUI) {
    console.log('[AddBook] ScannerUI available');
    window.ScannerUI.setupMobileOptimizations();
    window.ScannerUI.setupMobileFocusDetection();
  }
  
  // Update debug buttons
  updateDebugButtons();
  
  console.log('[AddBook] Scanner initialization complete');
});

// Show/hide debug buttons based on environment
function updateDebugButtons() {
  const debugBtn = document.getElementById('debugBtn');
  const cleanupBtn = document.getElementById('cleanupBtn');
  const nuclearBtn = document.getElementById('nuclearBtn');
  
  if (debugBtn) {
    debugBtn.style.display = '{{ "block" if config.DEBUG_MODE or current_user.debug_enabled else "none" }}';
  }
  
  if (cleanupBtn) {
    cleanupBtn.style.display = 'block'; // Always show cleanup button
  }
  
  if (nuclearBtn) {
    nuclearBtn.style.display = 'block'; // Always show nuclear button
  }
}

// Debug scanner function
function debugScanner() {
  console.log('[AddBook] Debug scanner called');
  
  if (window.ScannerCore && window.ScannerCore.debugScannerSystem) {
    const debugInfo = window.ScannerCore.debugScannerSystem();
    console.log('[AddBook] Scanner debug info:', debugInfo);
    
    // Show debug info in a more user-friendly way
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      const availableScanners = [];
      if (debugInfo.hasStartNativeScanner) availableScanners.push('Native');
      if (debugInfo.hasStartBrowserScanner) availableScanners.push('Browser');
      
      window.ScannerUI.showNotification(
        `Scanner Debug: ${availableScanners.length} scanner(s) available. Check console for details.`, 
        'info'
      );
    }
  } else {
    console.error('[AddBook] ScannerCore.debugScannerSystem not available');
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      window.ScannerUI.showNotification('Debug function not available', 'error');
    }
  }
}

// Manual camera cleanup function
async function manualCameraCleanup() {
  console.log('[AddBook] Manual camera cleanup requested...');
  
  try {
    // Stop scanner if active
    if (window.ScannerCore && window.ScannerCore.stopScanner) {
      await window.ScannerCore.stopScanner();
    }
    
    // Force camera cleanup
    if (window.ScannerCore && window.ScannerCore.forceCameraCleanup) {
      await window.ScannerCore.forceCameraCleanup();
    }
    
    // Additional aggressive cleanup
    await aggressiveCameraCleanup();
    
    // Show success message
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      window.ScannerUI.showNotification('Camera released successfully', 'success');
    }
    
    console.log('[AddBook] Manual camera cleanup completed');
    
  } catch (error) {
    console.error('[AddBook] Error during manual camera cleanup:', error);
    
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      window.ScannerUI.showNotification('Error releasing camera: ' + error.message, 'error');
    }
  }
}

// Aggressive camera cleanup function
async function aggressiveCameraCleanup() {
  console.log('[AddBook] Performing aggressive camera cleanup...');
  
  try {
    // Stop all video elements
    const allVideos = document.querySelectorAll('video');
    allVideos.forEach((video, index) => {
      console.log('[AddBook] Aggressive cleanup - stopping video', index);
      if (video.srcObject) {
        const stream = video.srcObject;
        if (stream && stream.getTracks) {
          stream.getTracks().forEach(track => {
            console.log('[AddBook] Stopping track:', track.kind, track.label);
            track.stop();
          });
        }
        video.srcObject = null;
      }
      video.pause();
    });
    
    // Clear global stream references
    if (window.currentMediaStream) {
      console.log('[AddBook] Clearing global media stream reference');
      if (window.currentMediaStream.getTracks) {
        window.currentMediaStream.getTracks().forEach(track => track.stop());
      }
      window.currentMediaStream = null;
    }
    
    // Force camera release by temporarily removing video element from DOM
    console.log('[ScannerZXing] Temporarily removing video element from DOM to force camera release...');
    const video = document.getElementById('scanner-video');
    if (video) {
      const parent = video.parentNode;
      if (parent) {
        parent.removeChild(video);
        
        // Wait longer for browser to process the removal
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Don't re-add the video element immediately - let it stay removed
        // The scanner viewport will be hidden anyway
        console.log('[ScannerZXing] Video element removed from DOM - keeping it removed');
      }
    }
    
    // Browser-specific cleanup
    await browserSpecificCameraCleanup();
    
    console.log('[AddBook] Aggressive camera cleanup completed');
    
  } catch (error) {
    console.error('[AddBook] Error during aggressive cleanup:', error);
  }
}

// Browser-specific camera cleanup
async function browserSpecificCameraCleanup() {
  console.log('[AddBook] Performing browser-specific camera cleanup...');
  
  const userAgent = navigator.userAgent;
  let browser = 'Unknown';
  
  if (userAgent.includes('Chrome')) {
    browser = 'Chrome';
  } else if (userAgent.includes('Firefox')) {
    browser = 'Firefox';
  } else if (userAgent.includes('Safari')) {
    browser = 'Safari';
  } else if (userAgent.includes('Edge')) {
    browser = 'Edge';
  }
  
  console.log('[AddBook] Detected browser:', browser);
  
  try {
    if (browser === 'Chrome') {
      // Chrome-specific cleanup
      console.log('[AddBook] Chrome-specific cleanup...');
      
      // Force stop any remaining getUserMedia streams
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        try {
          // Create a temporary stream and immediately stop it to force camera release
          const tempStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              width: { ideal: 1 }, 
              height: { ideal: 1 } 
            } 
          });
          tempStream.getTracks().forEach(track => {
            console.log('[AddBook] Stopping temporary track:', track.kind);
            track.stop();
          });
          console.log('[AddBook] Temporary stream created and stopped');
          
          // Wait a bit for Chrome to process the stop
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (error) {
          console.log('[AddBook] Could not create temporary stream (expected if camera is busy):', error.message);
        }
      }
      
      // Try to revoke permissions (Chrome specific)
      if (navigator.permissions && navigator.permissions.query) {
        try {
          const permission = await navigator.permissions.query({ name: 'camera' });
          console.log('[AddBook] Camera permission state:', permission.state);
        } catch (error) {
          console.log('[AddBook] Could not query camera permissions:', error.message);
        }
      }
      
    } else if (browser === 'Firefox') {
      // Firefox-specific cleanup
      console.log('[AddBook] Firefox-specific cleanup...');
      
      // Firefox sometimes needs multiple cleanup attempts
      for (let i = 0; i < 3; i++) {
        try {
          const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
          tempStream.getTracks().forEach(track => track.stop());
          await new Promise(resolve => setTimeout(resolve, 50));
        } catch (error) {
          break;
        }
      }
      
    } else {
      // Generic cleanup for other browsers
      console.log('[AddBook] Generic browser cleanup...');
      
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        try {
          const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
          tempStream.getTracks().forEach(track => track.stop());
        } catch (error) {
          console.log('[AddBook] Generic cleanup error:', error.message);
        }
      }
    }
    
    // Final check - try to enumerate devices to see if camera is still active
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      console.log('[AddBook] Final device count:', videoDevices.length);
      
      // Show user feedback about camera status
      if (window.ScannerUI && window.ScannerUI.showNotification) {
        window.ScannerUI.showNotification(
          `Camera cleanup completed. Browser may take a moment to update the camera indicator.`, 
          'info'
        );
      }
      
    } catch (error) {
      console.log('[AddBook] Could not enumerate devices:', error.message);
    }
    
  } catch (error) {
    console.error('[AddBook] Browser-specific cleanup error:', error);
  }
}

// Global aggressive cleanup function for console debugging
window.forceCameraRelease = async function() {
  console.log('[AddBook] Force camera release called from console...');
  await aggressiveCameraCleanup();
  console.log('[AddBook] Force camera release completed');
  
  // Show user feedback
  if (window.ScannerUI && window.ScannerUI.showNotification) {
    window.ScannerUI.showNotification(
      'Force camera release completed. Check if camera indicator is now off.', 
      'success'
    );
  }
};

// Nuclear cleanup function - last resort for stubborn camera connections
window.nuclearCameraRelease = async function() {
  console.log('[AddBook] Nuclear camera release called from console...');
  
  try {
    // Call scanner core nuclear cleanup
    if (window.ScannerCore && window.ScannerCore.nuclearCleanup) {
      console.log('[AddBook] Calling scanner core nuclear cleanup...');
      await window.ScannerCore.nuclearCleanup();
    } else {
      console.log('[AddBook] Scanner core nuclear cleanup not available');
    }
    
    // Additional page-level nuclear cleanup
    console.log('[AddBook] Performing page-level nuclear cleanup...');
    
    // Step 1: Stop all video streams
    const allVideos = document.querySelectorAll('video');
    allVideos.forEach((video, index) => {
      console.log('[AddBook] Stopping video stream', index);
      if (video.srcObject) {
        const stream = video.srcObject;
        if (stream && stream.getTracks) {
          stream.getTracks().forEach(track => track.stop());
        }
        video.srcObject = null;
        video.pause();
      }
    });
    
    // Step 2: SCORCHED EARTH - Forcefully kill any remaining MediaStreams
    console.log('[AddBook] Step 2: Scorched earth cleanup...');
    try {
      // Get a new stream and immediately stop all tracks
      console.log('[AddBook] Forcefully killing any remaining MediaStreams...');
      const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
      tempStream.getTracks().forEach(track => {
        console.log('[AddBook] Force stopping track:', track.kind, track.label);
        track.stop();
      });
      console.log('[AddBook] Scorched earth cleanup completed');
    } catch (scorchedError) {
      console.log('[AddBook] No active stream to force stop (this is good):', scorchedError.message);
    }
    
    // Step 3: Remove all video elements
    allVideos.forEach((video, index) => {
      if (video.parentNode) {
        video.parentNode.removeChild(video);
        console.log('[AddBook] Removed video element', index);
      }
    });
    
    // Step 4: Clear global references
    window.currentMediaStream = null;
    
    // Step 5: Force garbage collection
    if (window.gc) {
      console.log('[AddBook] Force garbage collection...');
      for (let i = 0; i < 3; i++) {
        window.gc();
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    // Step 6: Long delay for browser to process
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Step 7: Recreate scanner video element
    const scannerContainer = document.getElementById('scanner-viewport');
    if (scannerContainer) {
      const newVideo = document.createElement('video');
      newVideo.id = 'scanner-video';
      newVideo.autoplay = true;
      newVideo.playsInline = true;
      newVideo.muted = true;
      newVideo.style.width = '100%';
      newVideo.style.height = '100%';
      newVideo.style.objectFit = 'cover';
      
      scannerContainer.appendChild(newVideo);
      console.log('[AddBook] Scanner video element recreated');
    }
    
    console.log('[AddBook] Nuclear camera release completed');
    
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      window.ScannerUI.showNotification(
        'Nuclear camera release completed. All video elements recreated.', 
        'success'
      );
    }
    
  } catch (error) {
    console.error('[AddBook] Error during nuclear camera release:', error);
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      window.ScannerUI.showNotification(
        'Nuclear camera release failed: ' + error.message, 
        'error'
      );
    }
  }
};

// Console commands for debugging
console.log('[AddBook] Available console commands:');
console.log('- nuclearCameraRelease() - Nuclear cleanup for stubborn camera connections');
console.log('- checkCameraStatus() - Check current camera status');
console.log('- testScanner() - Test scanner functionality');
console.log('- window.ScannerCore.nuclearCleanup() - Core nuclear cleanup');
console.log('- window.ScannerZXing.nuclearCameraCleanup() - ZXing nuclear cleanup');

// Check camera status function
window.checkCameraStatus = async function() {
  console.log('[AddBook] Checking camera status...');
  
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(device => device.kind === 'videoinput');
    
    console.log('[AddBook] Camera status check:');
    console.log('- Available video devices:', videoDevices.length);
    videoDevices.forEach((device, index) => {
      console.log(`  ${index}: ${device.label || 'Unknown device'} (${device.deviceId})`);
    });
    
    // Check if there are any active streams
    const allVideos = document.querySelectorAll('video');
    const activeVideos = Array.from(allVideos).filter(video => video.srcObject);
    
    console.log('- Active video elements:', activeVideos.length);
    console.log('- Global media stream:', window.currentMediaStream ? 'Active' : 'None');
    
    // Check permissions
    let permissionState = 'Unknown';
    if (navigator.permissions && navigator.permissions.query) {
      try {
        const permission = await navigator.permissions.query({ name: 'camera' });
        permissionState = permission.state;
      } catch (error) {
        permissionState = 'Could not query';
      }
    }
    
    console.log('- Camera permission state:', permissionState);
    
    // Show user-friendly status
    const status = {
      devices: videoDevices.length,
      activeVideos: activeVideos.length,
      globalStream: !!window.currentMediaStream,
      permission: permissionState
    };
    
    console.log('[AddBook] Camera status summary:', status);
    
    if (window.ScannerUI && window.ScannerUI.showNotification) {
      let message = `Camera Status: ${status.devices} devices, ${status.activeVideos} active videos`;
      if (status.globalStream) {
        message += ', global stream active';
      }
      message += `. Permission: ${status.permission}`;
      
      window.ScannerUI.showNotification(message, 'info');
    }
    
    return status;
    
  } catch (error) {
    console.error('[AddBook] Error checking camera status:', error);
    return { error: error.message };
  }
};

// Global test function for debugging (can be called from browser console)
window.testScanner = async function() {
  console.log('[AddBook] Testing scanner from global function...');
  
  // Run debug first
  if (window.ScannerCore && window.ScannerCore.debugScannerSystem) {
    const debugInfo = window.ScannerCore.debugScannerSystem();
    console.log('[AddBook] Debug info:', debugInfo);
    
    // Check if we have any scanner available
    const hasNative = debugInfo.hasStartNativeScanner;
    const hasBrowser = debugInfo.hasStartBrowserScanner;
    
    if (!hasNative && !hasBrowser) {
      console.error('[AddBook] No scanner available!');
      alert('No scanner available. Check console for details.');
      return;
    }
    
    console.log('[AddBook] Available scanners - Native:', hasNative, 'Browser:', hasBrowser);
    
    // Try to start scanner
    try {
      console.log('[AddBook] Attempting to start scanner...');
      if (window.ScannerCore && window.ScannerCore.startSmartScanner) {
        await window.ScannerCore.startSmartScanner();
        console.log('[AddBook] Scanner started successfully');
      } else {
        console.error('[AddBook] startSmartScanner not available');
        alert('startSmartScanner function not available');
      }
    } catch (error) {
      console.error('[AddBook] Failed to start scanner:', error);
      alert('Failed to start scanner: ' + error.message);
    }
  } else {
    console.error('[AddBook] debugScannerSystem not available');
    alert('Debug function not available');
  }
};

// Ensure camera cleanup on page unload
window.addEventListener('beforeunload', function() {
  console.log('[AddBook] Page unloading - ensuring camera cleanup...');
  
  // Stop scanner if active
  if (window.ScannerCore && window.ScannerCore.stopScanner) {
    window.ScannerCore.stopScanner().catch(error => {
      console.warn('[AddBook] Error stopping scanner on unload:', error);
    });
  }
  
  // Force camera cleanup
  if (window.ScannerCore && window.ScannerCore.forceCameraCleanup) {
    window.ScannerCore.forceCameraCleanup().catch(error => {
      console.warn('[AddBook] Error during force cleanup on unload:', error);
    });
  }
  
  // Explicitly stop any remaining video streams
  const allVideos = document.querySelectorAll('video');
  allVideos.forEach((video, index) => {
    if (video.srcObject) {
      console.log('[AddBook] Stopping video stream on unload:', index);
      const stream = video.srcObject;
      if (stream && stream.getTracks) {
        stream.getTracks().forEach(track => track.stop());
      }
      video.srcObject = null;
    }
  });
  
  // Clear global stream reference
  if (window.currentMediaStream) {
    console.log('[AddBook] Clearing global media stream on unload');
    if (window.currentMediaStream.getTracks) {
      window.currentMediaStream.getTracks().forEach(track => track.stop());
    }
    window.currentMediaStream = null;
  }
});
</script>
{% endblock %}
